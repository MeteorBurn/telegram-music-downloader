# Как работает очередь скачивания

## Обзор

Файлы скачиваются **не в порядке сообщений**, а по **приоритету, основанному на размере файла**. Это сделано для оптимизации процесса скачивания.

---

## Этап 1: Парсинг сообщений

### Порядок чтения сообщений

Сообщения читаются **последовательно от старых к новым**:

```python
# src/message_parser.py, строка 51
async for message in self.client.iter_messages(entity, reverse=True):
```

**Параметр `reverse=True`** означает чтение от самого старого к самому новому сообщению.

### Точка начала парсинга

Система определяет, откуда начинать чтение, по следующему приоритету:

1. **`last_processed_id`** (приоритет #1)
   - Продолжает с последнего обработанного сообщения
   - Позволяет возобновлять скачивание после остановки

2. **`date_from`** из config.yaml (приоритет #2)
   - Начинает с указанной даты
   - Пример: `from: "2025-01-01"`

3. **С самого начала канала** (если ничего не указано)
   - Обрабатывает весь канал с первого сообщения

### Пример последовательности

```
Message ID: 100 → 101 → 102 → 103 → 104 → 105 → ...
           (старые)                         (новые)
```

---

## Этап 2: Добавление в очередь

### Приоритетная очередь

Файлы добавляются в **приоритетную очередь** (`asyncio.PriorityQueue`), которая использует `heapq` для автоматической сортировки.

```python
# src/download_queue.py
class DownloadQueue:
    def __init__(self, max_size: int = 100):
        self._queue = asyncio.PriorityQueue(maxsize=max_size)
```

### Ключевой момент: Расчёт приоритета

**Приоритет = размер файла в МБ** (меньшие файлы имеют более высокий приоритет):

```python
# src/download_queue.py, строки 54-55
file_size_mb = task.media_info.get('file_size', 0) / (1024 * 1024)
task.priority = int(file_size_mb)  # Меньшие файлы скачаются первыми
```

### Как работает приоритет

| Файл | Размер | Приоритет | Порядок скачивания |
|------|--------|-----------|-------------------|
| track3.wav | 3.5 MB | 3 | 1-й (самый высокий приоритет) |
| track4.mp3 | 5.1 MB | 5 | 2-й |
| track1.mp3 | 8.7 MB | 8 | 3-й |
| track2.flac | 45.2 MB | 45 | 4-й (самый низкий приоритет) |

**Правило:** Меньшее число приоритета = выше приоритет = скачается раньше

---

## Этап 3: Порядок скачивания

### Пример сценария

#### Шаг 1: Парсинг сообщений (по порядку)

```
Message 100: track1.mp3 (8 MB)   → добавлено в очередь с приоритетом 8
Message 101: track2.flac (45 MB) → добавлено в очередь с приоритетом 45
Message 102: track3.wav (3 MB)   → добавлено в очередь с приоритетом 3
Message 103: track4.mp3 (15 MB)  → добавлено в очередь с приоритетом 15
```

#### Шаг 2: Автоматическая сортировка в очереди

```
┌─────────────────────────────────────────────────────────┐
│  ОЧЕРЕДЬ НА СКАЧИВАНИЕ (sorted by priority)            │
├─────────────────────────────────────────────────────────┤
│  1. track3.wav   (msg 102) - приоритет 3  ← ПЕРВЫМ     │
│  2. track1.mp3   (msg 100) - приоритет 8               │
│  3. track4.mp3   (msg 103) - приоритет 15              │
│  4. track2.flac  (msg 101) - приоритет 45  ← ПОСЛЕДНИМ │
└─────────────────────────────────────────────────────────┘
```

#### Шаг 3: Фактический порядок скачивания

```
Файлы скачиваются: 102 → 100 → 103 → 101
                   НЕ в порядке message ID!
```

### Визуализация процесса

```
ПАРСИНГ (по порядку):        ОЧЕРЕДЬ (по приоритету):     СКАЧИВАНИЕ:
  
  100 (8 MB)  ───┐               3. track3.wav (3 MB)         1. Message 102
                 │                                            
  101 (45 MB) ───┤──→ Сортировка  8. track1.mp3 (8 MB)       2. Message 100
                 │                                            
  102 (3 MB)  ───┤──→ по размеру  15. track4.mp3 (15 MB)     3. Message 103
                 │                                            
  103 (15 MB) ───┘               45. track2.flac (45 MB)      4. Message 101
```

---

## Почему такой подход?

### ✓ Быстрая видимая обратная связь

Маленькие файлы скачиваются быстро → пользователь сразу видит результаты работы программы.

### ✓ Эффективное использование воркеров

При многопоточной загрузке:
- Воркер 1 качает большой файл (45 MB) - занят 5 минут
- Воркер 2 качает маленький файл (3 MB) - освобождается через 10 секунд
- Воркер 3 качает средний файл (8 MB) - освобождается через 1 минуту

Результат: воркеры 2 и 3 могут обработать больше файлов, пока воркер 1 занят.

### ✓ Лучшее использование пропускной способности сети

Смешивание файлов разного размера позволяет:
- Избежать простоя при ожидании больших файлов
- Более равномерно нагружать канал
- Быстрее получать статистику о прогрессе

### ✓ Устойчивость к сбоям

Если большой файл упал с ошибкой:
- Остальные воркеры продолжают работу с маленькими файлами
- Меньше влияние на общий прогресс
- Возможность быстро повторить попытку с проблемным файлом

---

## Как изменить поведение очереди

### Вариант 1: Скачивать в порядке сообщений

**Изменить:** `src/download_queue.py`, строка 55

```python
# Текущий код:
task.priority = int(file_size_mb)

# Изменить на:
task.priority = media_info['message_id']
```

**Результат:** Старые сообщения скачиваются первыми, независимо от размера файла.

---

### Вариант 2: Скачивать сначала БОЛЬШИЕ файлы

**Изменить:** `src/download_queue.py`, строка 55

```python
# Изменить на:
task.priority = -int(file_size_mb)  # Отрицательное значение
```

**Результат:** Большие файлы имеют более высокий приоритет.

**Пример:**
- 45 MB → приоритет -45 (скачается первым)
- 8 MB → приоритет -8
- 3 MB → приоритет -3 (скачается последним)

---

### Вариант 3: Скачивать в порядке даты публикации

**Изменить:** `src/download_queue.py`, строка 55

```python
# Изменить на:
task.priority = int(media_info['publish_date'].timestamp())
```

**Результат:** Сообщения с более ранней датой публикации скачиваются первыми.

---

### Вариант 4: Случайный порядок

**Изменить:** `src/download_queue.py`

```python
# Добавить импорт в начало файла:
import random

# Изменить строку 55:
task.priority = random.randint(0, 10000)
```

**Результат:** Файлы скачиваются в случайном порядке.

---

### Вариант 5: Комбинированный приоритет

**Пример:** Сначала по дате, потом по размеру

```python
# Изменить строку 55:
date_priority = int(media_info['publish_date'].timestamp()) // 100000
size_priority = int(file_size_mb)
task.priority = date_priority * 1000 + size_priority
```

**Результат:** Группировка по дате, внутри группы - сначала маленькие файлы.

---

## Дополнительная информация

### PriorityQueue и heapq

- `PriorityQueue` использует **min-heap** структуру данных
- Элемент с **наименьшим** приоритетом всегда извлекается первым
- Сложность операций: O(log n) для добавления/извлечения

### Равные приоритеты

При равных приоритетах (например, два файла по 5 MB):
- Порядок может быть **любым**
- Зависит от внутренней реализации heapq
- Для гарантированного порядка используйте кортежи:

```python
task.priority = (int(file_size_mb), message_info['message_id'])
```

Первым критерием будет размер, вторым - ID сообщения.

### Влияние concurrent downloads

При использовании нескольких воркеров (например, `--workers 3`):
- Воркеры берут задачи из очереди **одновременно**
- Видимый порядок может отличаться от порядка в очереди
- Файлы могут завершаться в разное время из-за:
  - Разной скорости скачивания
  - Rate limiting
  - Сетевых задержек

### Rate Limiting

Rate limiter контролирует частоту запросов к Telegram API:

```python
# src/download_queue.py
class RateLimiter:
    def __init__(self, requests_per_second: float = 2.0, burst_size: int = 5):
```

- `requests_per_second`: максимум запросов в секунду
- `burst_size`: размер "буфера" для пачки запросов

**Влияние на порядок:**
- Воркеры могут ждать токены для запросов
- Видимый порядок скачивания может быть не таким, как в очереди
- Помогает избежать блокировки от Telegram за превышение лимитов

---

## Отслеживание прогресса

### Статистика очереди

```python
stats = queue.get_stats()
# {
#     'total_added': 100,
#     'total_completed': 45,
#     'total_failed': 2,
#     'current_size': 53,
#     'pending_tasks': 53,
#     'queue_size': 53,
#     'is_empty': False,
#     'is_full': False
# }
```

### Просмотр прогресса

Используйте флаг `--progress` для просмотра в реальном времени:

```bash
python src/main.py --progress
```

**Отображается:**
- Текущий размер очереди
- Количество активных воркеров
- Статистика скачанных/пропущенных файлов
- Информация о текущих загрузках

---

## Связанные файлы

- `src/download_queue.py` - реализация очереди и приоритетов
- `src/message_parser.py` - парсинг сообщений
- `src/download_worker.py` - воркеры для скачивания
- `src/download_coordinator.py` - координация процесса
- `src/main.py` - основной процесс

---

## FAQ

**Q: Можно ли отключить приоритизацию?**  
A: Да, используйте `task.priority = 0` для всех файлов или `task.priority = message_info['message_id']` для строгого порядка.

**Q: Почему некоторые файлы пропускаются?**  
A: Файлы пропускаются если:
- Уже скачаны (проверка по хешу)
- Не проходят фильтры (размер, формат, дата)
- Находятся в blacklist

**Q: Как скачивать только один файл за раз?**  
A: Используйте `--workers 1`:
```bash
python src/main.py --workers 1
```

**Q: Влияет ли порядок каналов в config.yaml?**  
A: Да, каналы обрабатываются последовательно в указанном порядке. Но внутри каждого канала применяется приоритизация по размеру.
